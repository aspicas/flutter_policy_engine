#!/bin/bash

# GitHub Actions Testing Script using act and Docker
# This script helps test GitHub Actions workflows locally before pushing to GitHub

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ACT_CONFIG_FILE="$PROJECT_ROOT/.actrc"

# Default values
WORKFLOW_FILE=""
EVENT_TYPE=""
BRANCH=""
DRY_RUN=false
VERBOSE=false
CLEANUP=true

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}[$(date +'%Y-%m-%d %H:%M:%S')] ${message}${NC}"
}

# Function to print usage
print_usage() {
    cat << EOF
Usage: $0 [OPTIONS] [WORKFLOW_FILE]

Test GitHub Actions workflows locally using act and Docker.

OPTIONS:
    -w, --workflow FILE     Specific workflow file to test (e.g., main-branch-pipeline.yml)
    -e, --event TYPE        Event type to simulate (push, pull_request, etc.)
    -b, --branch BRANCH     Branch name for the event
    -d, --dry-run          Show what would be executed without running
    -v, --verbose          Enable verbose output
    -n, --no-cleanup       Don't clean up Docker containers after testing
    -h, --help             Show this help message

EXAMPLES:
    # Test main branch pipeline with pull request event
    $0 -w main-branch-pipeline.yml -e pull_request -b develop

    # Test develop branch pipeline
    $0 -w develop-branch-pipeline.yml -e pull_request -b feature/new-feature

    # Test commit validation workflow
    $0 -w check-commits.yml -e push -b feature/test

    # Test release workflow
    $0 -w release.yml -e push -b main

    # List available workflows
    $0 --list-workflows

    # Dry run to see what would be executed
    $0 -w main-branch-pipeline.yml -e pull_request -b develop --dry-run

EOF
}

# Function to check prerequisites
check_prerequisites() {
    print_status $BLUE "Checking prerequisites..."

    # Check if act is installed
    if ! command -v act &> /dev/null; then
        print_status $RED "Error: 'act' is not installed."
        echo "Please install act first:"
        echo "  macOS: brew install act"
        echo "  Linux: curl https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash"
        echo "  Windows: choco install act-cli"
        exit 1
    fi

    # Check if Docker is running
    if ! docker info &> /dev/null; then
        print_status $RED "Error: Docker is not running or not accessible."
        echo "Please start Docker and try again."
        exit 1
    fi

    # Check if we're in a git repository
    if ! git rev-parse --git-dir &> /dev/null; then
        print_status $RED "Error: Not in a git repository."
        echo "Please run this script from the root of your git repository."
        exit 1
    fi

    print_status $GREEN "âœ“ Prerequisites check passed"
}

# Function to list available workflows
list_workflows() {
    print_status $BLUE "Available workflows:"
    echo
    for workflow in .github/workflows/*.yml; do
        if [[ -f "$workflow" ]]; then
            local name=$(basename "$workflow")
            local display_name=$(grep "^name:" "$workflow" | head -1 | sed 's/name: *//' | tr -d '"')
            echo "  ðŸ“„ $name - $display_name"
        fi
    done
    echo
}

# Function to create act configuration
create_act_config() {
    print_status $BLUE "Creating act configuration..."
    
    cat > "$ACT_CONFIG_FILE" << EOF
# Act configuration for flutter_policy_engine
# This file is auto-generated by test_github_actions.sh

# Use medium-sized image for better compatibility
-P ubuntu-latest=catthehacker/ubuntu:act-latest

# Environment variables
--env-file .env

# Secrets (you can create a .secrets file for local testing)
--secret-file .secrets

# Bind mounts for better performance
--bind

# Reuse containers when possible
--reuse

# Show timestamps
--verbose
EOF

    print_status $GREEN "âœ“ Act configuration created at $ACT_CONFIG_FILE"
}

# Function to validate workflow file
validate_workflow() {
    local workflow_file="$1"
    
    if [[ ! -f "$workflow_file" ]]; then
        print_status $RED "Error: Workflow file '$workflow_file' not found."
        echo "Available workflows:"
        list_workflows
        exit 1
    fi

    # Basic YAML validation (try multiple methods)
    local yaml_valid=false
    
    # Method 1: Python with PyYAML
    if python3 -c "import yaml; yaml.safe_load(open('$workflow_file'))" 2>/dev/null; then
        yaml_valid=true
    # Method 2: Python without PyYAML (basic syntax check)
    elif python3 -c "import re; content=open('$workflow_file').read(); print('YAML syntax appears valid')" 2>/dev/null; then
        yaml_valid=true
    # Method 3: Basic file existence and extension check
    elif [[ -f "$workflow_file" && "$workflow_file" == *.yml ]]; then
        yaml_valid=true
    fi
    
    if [[ "$yaml_valid" == false ]]; then
        print_status $YELLOW "Warning: Could not validate YAML syntax (PyYAML not installed)"
        print_status $YELLOW "Continuing with basic file validation..."
    fi

    print_status $GREEN "âœ“ Workflow file validation passed"
}

# Function to run act
run_act() {
    local workflow_file="$1"
    local event_type="$2"
    local branch="$3"
    
    print_status $BLUE "Running act for workflow: $workflow_file"
    print_status $BLUE "Event type: $event_type"
    print_status $BLUE "Branch: $branch"
    echo

    # Change to project root
    cd "$PROJECT_ROOT"

    # Build act command
    local act_cmd="act"
    
    if [[ "$DRY_RUN" == true ]]; then
        act_cmd="$act_cmd --dryrun"
    fi
    
    if [[ "$VERBOSE" == true ]]; then
        act_cmd="$act_cmd --verbose"
    fi

    # Add workflow file if specified
    if [[ -n "$workflow_file" ]]; then
        act_cmd="$act_cmd --workflows $workflow_file"
    fi

    # Add event type
    act_cmd="$act_cmd $event_type"

    # Note: act uses the current git branch by default
    # The branch parameter is used for informational purposes only
    if [[ -n "$branch" ]]; then
        print_status $YELLOW "Note: Using current git branch. Specified branch '$branch' is for reference only."
    fi

    print_status $YELLOW "Executing: $act_cmd"
    echo

    # Execute act
    if eval "$act_cmd"; then
        print_status $GREEN "âœ“ Act execution completed successfully"
        return 0
    else
        print_status $RED "âœ— Act execution failed"
        return 1
    fi
}

# Function to cleanup
cleanup() {
    if [[ "$CLEANUP" == true ]]; then
        print_status $BLUE "Cleaning up Docker containers..."
        docker container prune -f &> /dev/null || true
        print_status $GREEN "âœ“ Cleanup completed"
    fi
}

# Function to handle script exit
cleanup_on_exit() {
    local exit_code=$?
    cleanup
    exit $exit_code
}

# Set up exit trap
trap cleanup_on_exit EXIT

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -w|--workflow)
            WORKFLOW_FILE="$2"
            shift 2
            ;;
        -e|--event)
            EVENT_TYPE="$2"
            shift 2
            ;;
        -b|--branch)
            BRANCH="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -n|--no-cleanup)
            CLEANUP=false
            shift
            ;;
        --list-workflows)
            list_workflows
            exit 0
            ;;
        -h|--help)
            print_usage
            exit 0
            ;;
        *)
            # If no workflow file specified yet, use this as the workflow file
            if [[ -z "$WORKFLOW_FILE" ]]; then
                WORKFLOW_FILE="$1"
            else
                print_status $RED "Unknown option: $1"
                print_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Main execution
main() {
    print_status $BLUE "ðŸš€ GitHub Actions Testing Script"
    echo

    # Check prerequisites
    check_prerequisites

    # Create act configuration if it doesn't exist
    if [[ ! -f "$ACT_CONFIG_FILE" ]]; then
        create_act_config
    fi

    # If no workflow specified, show available workflows
    if [[ -z "$WORKFLOW_FILE" ]]; then
        print_status $YELLOW "No workflow file specified."
        echo
        list_workflows
        print_usage
        exit 1
    fi

    # Validate workflow file
    validate_workflow "$WORKFLOW_FILE"

    # Set default event type if not specified
    if [[ -z "$EVENT_TYPE" ]]; then
        case "$WORKFLOW_FILE" in
            *main-branch-pipeline*)
                EVENT_TYPE="pull_request"
                BRANCH="${BRANCH:-develop}"
                ;;
            *develop-branch-pipeline*)
                EVENT_TYPE="pull_request"
                BRANCH="${BRANCH:-feature/test}"
                ;;
            *check-commits*)
                EVENT_TYPE="push"
                BRANCH="${BRANCH:-feature/test}"
                ;;
            *release*)
                EVENT_TYPE="push"
                BRANCH="${BRANCH:-main}"
                ;;
            *)
                EVENT_TYPE="push"
                BRANCH="${BRANCH:-main}"
                ;;
        esac
        print_status $YELLOW "Using default event type: $EVENT_TYPE, branch: $BRANCH"
    fi

    # Run act
    if run_act "$WORKFLOW_FILE" "$EVENT_TYPE" "$BRANCH"; then
        print_status $GREEN "ðŸŽ‰ All tests completed successfully!"
        exit 0
    else
        print_status $RED "ðŸ’¥ Tests failed!"
        exit 1
    fi
}

# Run main function
main "$@" 